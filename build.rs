use std::fs;
use std::path::Path;

fn main() {
    println!("cargo:rerun-if-changed=data/recipes");
    println!("cargo:rerun-if-changed=assets/images/recipes");

    generate_recipe_assets();
}

fn generate_recipe_assets() {
    let recipes_dir = Path::new("data/recipes");
    let images_dir = Path::new("assets/images/recipes");

    if !recipes_dir.exists() {
        println!("cargo:warning=data/recipes directory not found");
        return;
    }

    // Collect all recipe JSON files
    let mut recipe_files = Vec::new();
    if let Ok(entries) = fs::read_dir(recipes_dir) {
        for entry in entries.flatten() {
            if let Some(file_name) = entry.file_name().to_str() {
                if file_name.ends_with(".json") && !file_name.starts_with("_") {
                    let recipe_id = file_name.trim_end_matches(".json");
                    recipe_files.push(recipe_id.to_string());
                }
            }
        }
    }

    // Collect all available images
    let mut available_images = Vec::new();
    if images_dir.exists() {
        if let Ok(entries) = fs::read_dir(images_dir) {
            for entry in entries.flatten() {
                if let Some(file_name) = entry.file_name().to_str() {
                    if file_name.ends_with(".jpg") || file_name.ends_with(".jpeg") || file_name.ends_with(".png") {
                        let image_id = file_name.split('.').next().unwrap_or("");
                        available_images.push(image_id.to_string());
                    }
                }
            }
        }
    }

    // Generate the recipe assets module
    let mut assets_code = String::new();
    assets_code.push_str("// Auto-generated by build.rs - DO NOT EDIT\n");
    assets_code.push_str("use dioxus::prelude::*;\n\n");

    // Generate asset declarations
    for image_id in &available_images {
        if recipe_files.contains(image_id) {
            assets_code.push_str(&format!(
                "const {}_IMAGE: Asset = asset!(\"/assets/images/recipes/{}.jpg\");\n",
                image_id.to_uppercase().replace("-", "_"),
                image_id
            ));
        }
    }

    assets_code.push_str("\npub fn get_recipe_image(recipe_id: &str) -> Option<Asset> {\n");
    assets_code.push_str("    match recipe_id {\n");

    for image_id in &available_images {
        if recipe_files.contains(image_id) {
            assets_code.push_str(&format!(
                "        \"{}\" => Some({}),\n",
                image_id,
                format!("{}_IMAGE", image_id.to_uppercase().replace("-", "_"))
            ));
        }
    }

    assets_code.push_str("        _ => None,\n");
    assets_code.push_str("    }\n");
    assets_code.push_str("}\n\n");

    // Generate recipe loading code
    assets_code.push_str("pub fn get_all_recipe_includes() -> Vec<&'static str> {\n");
    assets_code.push_str("    vec![\n");

    for recipe_id in &recipe_files {
        assets_code.push_str(&format!(
            "        include_str!(\"../data/recipes/{}.json\"),\n",
            recipe_id
        ));
    }

    assets_code.push_str("    ]\n");
    assets_code.push_str("}\n");

    // Write the generated file
    fs::write("src/generated_assets.rs", assets_code)
        .expect("Failed to write generated assets file");

    println!("cargo:warning=Generated assets for {} recipes with {} images",
             recipe_files.len(), available_images.len());
}