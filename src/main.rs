use dioxus::prelude::*;

mod models;
mod components;
mod services;
mod utils;
mod generated_assets; // Auto-generated by build script

use models::recipe::Recipe;
use components::{Header, RecipeList, SearchBar, RecipeModal};

fn main() {
    launch(App);
}

#[component]
fn App() -> Element {
    // Global app state
    let mut recipes = use_signal(|| Vec::<Recipe>::new());
    let mut loading = use_signal(|| true);
    let mut search_query = use_signal(|| String::new());
    let mut selected_cuisine = use_signal(|| None::<String>);
    let mut filter_spicy = use_signal(|| false);
    let mut selected_recipe = use_signal(|| None::<Recipe>);

    // Load recipes on app start
    use_effect(move || {
        spawn(async move {
            loading.set(true);
            match services::recipe_service::load_recipes().await {
                Ok(loaded_recipes) => {
                    recipes.set(loaded_recipes);
                }
                Err(error) => {
                    web_sys::console::log_1(&format!("Failed to load recipes: {}", error).into());
                    // Fallback to empty state - users will see "No recipes found"
                }
            }
            loading.set(false);
        });
    });

    // Filter recipes based on current filters
    let filtered_recipes = use_memo(move || {
        let query = search_query.read().to_lowercase();
        let cuisine_filter = selected_cuisine.read().clone();
        let spicy_filter = *filter_spicy.read();

        recipes
            .read()
            .iter()
            .filter(|recipe| {
                // Text search
                let matches_search = query.is_empty() ||
                    recipe.name.to_lowercase().contains(&query) ||
                    recipe.ingredients.iter().any(|ing|
                        ing.name.to_lowercase().contains(&query)
                    );

                // Cuisine filter
                let matches_cuisine = cuisine_filter.as_ref()
                    .map_or(true, |filter| recipe.cuisine.as_str() == filter);

                // Spicy filter
                let matches_spicy = !spicy_filter ||
                    recipe.spice_level.map_or(false, |level| level >= 3);

                matches_search && matches_cuisine && matches_spicy
            })
            .cloned()
            .collect::<Vec<_>>()
    });

    rsx! {
        document::Link { rel: "stylesheet", href: "https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;600;700&family=Inter:wght@300;400;500;600&display=swap" }

        style { {include_str!("../assets/style.css")} }

        div {
            class: "app",

            Header {
                title: "Flavours We Love üå∂Ô∏è"
            }

            main {
                class: "main-content",

                SearchBar {
                    query: search_query,
                    on_query_change: move |new_query: String| {
                        search_query.set(new_query);
                    }
                }

                div {
                    class: "filters",

                    select {
                        class: "cuisine-filter",
                        onchange: move |evt| {
                            let value = evt.value();
                            selected_cuisine.set(if value.is_empty() {
                                None
                            } else {
                                Some(value)
                            });
                        },

                        option { value: "", "All Cuisines" }
                        option { value: "Malaysian", "Malaysian" }
                        option { value: "Italian", "Italian" }
                        option { value: "British", "British" }
                        option { value: "Indian", "Indian" }
                        option { value: "Mexican", "Mexican" }
                        option { value: "Thai", "Thai" }
                        option { value: "Scottish-Italian", "Scottish-Italian" }
                    }

                    label {
                        class: "spicy-filter",
                        input {
                            r#type: "checkbox",
                            checked: *filter_spicy.read(),
                            onchange: move |evt| {
                                filter_spicy.set(evt.checked());
                            }
                        }
                        "Spicy Only üå∂Ô∏è"
                    }
                }

                if *loading.read() {
                    div {
                        class: "loading-state",
                        div { class: "loading-spinner" }
                        h3 { "Loading our delicious recipes..." }
                        p { "Preparing something special for you" }
                    }
                } else {
                    RecipeList {
                        recipes: filtered_recipes(),
                        on_recipe_click: move |recipe: Recipe| {
                            selected_recipe.set(Some(recipe));
                        }
                    }
                }
            }

            // Recipe detail modal
            if let Some(recipe) = selected_recipe.read().as_ref() {
                RecipeModal {
                    recipe: recipe.clone(),
                    on_close: move || {
                        selected_recipe.set(None);
                    }
                }
            }
        }
    }
}